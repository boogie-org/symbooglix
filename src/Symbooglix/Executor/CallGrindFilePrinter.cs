using System;
using Microsoft.Boogie;
using System.IO;
using System.Linq;
using System.Diagnostics;

namespace Symbooglix
{
    public class CallGrindFilePrinter
    {
        public static void Print(Program prog, string pathToProgram, TextWriter TW)
        {
            TW.WriteLine("# Callgrind file generated by Symbooglix");
            TW.WriteLine("# This file can be opened by KCacheGrind");

            // List supported counters
            TW.WriteLine("events: Covered");

            // Specifiy input file
            TW.WriteLine("fl={0}", pathToProgram);

            foreach (var impl in prog.TopLevelDeclarations.OfType<Implementation>())
            {
                TW.WriteLine("# Statistics for {0}", impl.Name);
                TW.WriteLine("fn={0}", impl.Name);

                foreach (var bb in impl.Blocks)
                {
                    TW.WriteLine("# BasicBlock:{0}", bb.Label);

                    // Handle Commands
                    foreach (var cmd in bb.Cmds)
                    {
                        if (cmd is CallCmd)
                        {
                            var callCmd = cmd as CallCmd;
                            TW.WriteLine("# Call into {0}", callCmd.Proc.Name);
                            TW.WriteLine("cfn={0}", callCmd.Proc.Name);

                            // FIXME: There should be a special statistics for CallCmd which records the target.
                            // Determine if call would of been to a Procedure or Impl
                            var calleeImpl = prog.TopLevelDeclarations.OfType<Implementation>().Where( x => x.Name == callCmd.Proc.Name);
                            int calleeLineNumber = 0;
                            if (calleeImpl.Count() > 0)
                            {
                                TW.WriteLine("# Call into implementation");
                                calleeLineNumber = calleeImpl.First().tok.line;
                            }
                            else
                            {
                                TW.WriteLine("# Call into procedure");
                                calleeLineNumber = callCmd.Proc.tok.line;
                            }


                            TW.WriteLine("calls={0} {1}", callCmd.GetInstructionStatistics().Covered, calleeLineNumber);

                            // FIXME: This is supposed to be the inclusive "cost" of calls to the proc/impl.
                            // We aren't sending the right number. We really need to walk to call graph bottom up
                            // instead of iterating over the impl/proc in an arbitrary order
                            TW.WriteLine("{0} {1}", callCmd.tok.line, callCmd.GetInstructionStatistics().Covered);

                            TW.WriteLine("cfn={0}", impl.Name);
                        }
                        else
                        {
                            TW.WriteLine("{0} {1}", cmd.tok.line, cmd.GetInstructionStatistics().Covered);
                        }
                    }


                    // Handle TransferCmd
                    if (bb.TransferCmd is ReturnCmd)
                    {
                        TW.WriteLine("{0} {1}", bb.TransferCmd.tok.line, bb.TransferCmd.GetInstructionStatistics().Covered);
                    }
                    else
                    {
                        Debug.Assert(bb.TransferCmd is GotoCmd);
                        var gotoCmd = bb.TransferCmd as GotoCmd;

                        var gotoCmdStats = gotoCmd.GetInstructionStatistics() as GotoInstructionStatistics;

                        if (gotoCmd.labelTargets.Count == 1)
                        {
                            // Non conditional jump
                            int targetLineNumber = gotoCmd.labelTargets[0].tok.line;
                            TW.WriteLine("jump={0} {1}", gotoCmdStats.TotalJumps, targetLineNumber);
                            TW.WriteLine("{0}", gotoCmd.tok.line);
                        }
                        else
                        {
                            // Conditional jump
                            foreach (var target in gotoCmd.labelTargets)
                            {
                                int targetLineNumber = target.tok.line;
                                TW.WriteLine("jcnd={0}/{1} {2}", gotoCmdStats.GetJumpsTo(target), gotoCmdStats.TotalJumps, targetLineNumber);
                                TW.WriteLine("{0}", gotoCmd.tok.line);
                            }
                        }
                        TW.WriteLine("{0} {1}", gotoCmd.tok.line, gotoCmdStats.Covered);
                    }
                }
            }
        }
    }
}

